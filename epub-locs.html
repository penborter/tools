<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EPUB LOC Estimator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link rel="preconnect" href="https://rsms.me/">
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
    <style>
        :root {
            --bg: hsl(70, 25%, 95%);
            --fg: hsl(175, 25%, 22%);
            --bg-accent-1: hsl(150, 15%, 60%);
            --bg-accent-2: hsl(70, 15%, 97%);
            --bg-accent-3: hsl(150, 15%, 80%);
            --fg-accent-1: hsl(165, 25%, 45%);
            --fg-accent-2: hsl(166, 15%, 32%);
            --shadow-color: rgba(0, 0, 0, 0.05);
            --shadow: 0 2px 4px var(--shadow-color), 0 4px 8px var(--shadow-color), 0 8px 16px var(--shadow-color);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--bg);
            color: var(--fg);
            line-height: 1.5;
            letter-spacing: -0.004em;
            padding: 2rem;
            min-height: 100vh;
        }

        .container {
            max-width: 650px;
            margin: 0 auto;
        }

        h1 {
            font-size: 1.25rem;
            font-weight: 500;
            margin: 0 0 2rem 0;
        }

        h2 {
            font-size: 1.125em;
            font-weight: 600;
            margin: 2rem 0 1rem 0;
            padding-top: 1.5rem;
            border-top: 1px solid var(--bg-accent-3);
        }

        p {
            margin: 0.5rem 0 1.5rem 0;
        }

        .drop-zone {
            border: 2px dashed var(--bg-accent-1);
            padding: 3rem 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            background: var(--bg-accent-2);
        }

        .drop-zone:hover, .drop-zone.dragover {
            border-color: var(--fg-accent-1);
            background: var(--bg);
        }

        .drop-zone-text {
            color: var(--bg-accent-1);
        }

        .drop-zone:hover .drop-zone-text {
            color: var(--fg);
        }

        input[type="file"] {
            display: none;
        }

        .results {
            display: none;
        }

        .results.visible {
            display: block;
        }

        .summary-box {
            background: var(--bg-accent-2);
            border: 1px solid var(--bg-accent-3);
            padding: 1.5em;
            margin: 1em 0;
            box-shadow: var(--shadow);
        }

        .summary-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        .summary-item {
            display: flex;
            flex-direction: column;
        }

        .summary-label {
            font-size: 0.85em;
            color: var(--bg-accent-1);
            margin-bottom: 0.25rem;
        }

        .summary-value {
            font-size: 1.25rem;
            font-weight: 600;
        }

        .book-title {
            grid-column: 1 / -1;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--bg-accent-3);
            margin-bottom: 0.5rem;
        }

        .book-title .summary-value {
            font-size: 1.1rem;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            border: 1px solid var(--fg);
            margin: 1rem 0;
            font-size: 0.9em;
        }

        thead tr {
            background: var(--fg);
            color: var(--bg);
        }

        th, td {
            padding: 0.5rem 0.75rem;
            text-align: left;
        }

        th {
            font-weight: 600;
        }

        tr {
            background: var(--bg-accent-2);
        }

        tr:nth-child(even) {
            background: var(--bg);
        }

        tbody tr:hover {
            filter: brightness(110%);
        }

        .loc-lookup {
            margin-top: 2rem;
        }

        .input-row {
            display: flex;
            gap: 1rem;
            align-items: flex-end;
        }

        .input-group {
            flex: 1;
        }

        label {
            display: block;
            font-size: 0.85em;
            color: var(--bg-accent-1);
            margin-bottom: 0.5rem;
        }

        input[type="number"] {
            width: 100%;
            padding: 0.6rem 0.8rem;
            border: 1px solid var(--bg-accent-3);
            font-family: inherit;
            font-size: 1rem;
            background: var(--bg);
            color: var(--fg);
        }

        input[type="number"]:focus {
            outline: none;
            border-color: var(--fg-accent-1);
        }

        button {
            padding: 0.6rem 1.2rem;
            background: var(--fg);
            color: var(--bg);
            border: none;
            font-family: inherit;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        button:hover {
            background: var(--fg-accent-2);
        }

        .lookup-result {
            margin-top: 1rem;
            padding: 1rem;
            background: var(--bg-accent-2);
            border: 1px solid var(--bg-accent-3);
            display: none;
        }

        .lookup-result.visible {
            display: block;
        }

        .progress-bar-container {
            height: 8px;
            background: var(--bg-accent-3);
            overflow: hidden;
            margin: 0.5rem 0;
        }

        .progress-bar {
            height: 100%;
            background: var(--fg-accent-1);
            transition: width 0.3s ease;
        }

        .error-message {
            background: #fef2f2;
            border: 1px solid #f05d5e;
            color: #b91c1c;
            padding: 1rem;
            margin: 1rem 0;
            display: none;
        }

        footer {
            font-size: 14px;
            color: var(--bg-accent-1);
            padding: 2em 0;
            margin-top: 3em;
            border-top: 1px solid var(--bg-accent-1);
        }

        footer a {
            color: var(--bg-accent-1);
            margin-right: 1em;
            text-decoration: none;
        }

        footer a:hover {
            color: var(--fg);
        }

        .error-message.visible {
            display: block;
        }

        .note {
            font-size: 0.85em;
            color: var(--bg-accent-1);
            margin-top: 0.5rem;
        }

        .reset-btn {
            background: transparent;
            color: var(--bg-accent-1);
            border: 1px solid var(--bg-accent-3);
            margin-top: 2rem;
        }

        .reset-btn:hover {
            color: var(--fg);
            border-color: var(--fg-accent-1);
        }

        footer {
            margin-top: 4rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--bg-accent-3);
            font-size: 14px;
            color: var(--bg-accent-1);
        }

        footer a {
            color: var(--fg);
            text-underline-offset: 3px;
            text-decoration-color: var(--bg-accent-1);
            text-decoration-thickness: 1.5px;
        }

        footer a:hover {
            text-decoration-color: var(--fg-accent-1);
            text-decoration-thickness: 2px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>EPUB LOC Estimator</h1>
        
        <p>Estimate Kindle-style location (LOC) counts for EPUB files. Useful for tracking reading progress and contextualizing highlight positions.</p>

        <div class="drop-zone" id="dropZone">
            <p class="drop-zone-text">Drop an EPUB file here, or click to select</p>
            <input type="file" id="fileInput" accept=".epub">
        </div>

        <div class="error-message" id="errorMessage"></div>

        <div class="results" id="results">
            <h2>Summary</h2>
            
            <div class="summary-box">
                <div class="summary-grid">
                    <div class="summary-item book-title">
                        <span class="summary-label">Title</span>
                        <span class="summary-value" id="bookTitle">—</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">Estimated Total LOCs</span>
                        <span class="summary-value" id="totalLocs">—</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">Total Characters</span>
                        <span class="summary-value" id="totalChars">—</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">Chapters</span>
                        <span class="summary-value" id="chapterCount">—</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">Estimated Words</span>
                        <span class="summary-value" id="wordCount">—</span>
                    </div>
                </div>
            </div>

            <p class="note">LOC estimate uses ~128 bytes per location, which is the commonly accepted approximation of Kindle's algorithm.</p>

            <h2>Chapter Breakdown</h2>
            
            <table>
                <thead>
                    <tr>
                        <th>Chapter</th>
                        <th>LOC Start</th>
                        <th>LOC End</th>
                        <th>% of Book</th>
                    </tr>
                </thead>
                <tbody id="chapterTable">
                </tbody>
            </table>

            <div class="loc-lookup">
                <h2>LOC Lookup</h2>
                <p>Enter a highlight's LOC to find where it falls in the book.</p>
                
                <div class="input-row">
                    <div class="input-group">
                        <label for="locInput">Location Number</label>
                        <input type="number" id="locInput" min="1" placeholder="e.g. 1234">
                    </div>
                    <button id="lookupBtn">Look Up</button>
                </div>

                <div class="lookup-result" id="lookupResult">
                    <div class="progress-bar-container">
                        <div class="progress-bar" id="progressBar"></div>
                    </div>
                    <p id="lookupText"></p>
                </div>
            </div>

            <button class="reset-btn" id="resetBtn">Analyze Another EPUB</button>
        </div>

        <footer>
            EPUB LOC Estimator — <a href="https://ben.report">ben.report</a>
        </footer>
    </div>

    <script>
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const results = document.getElementById('results');
        const errorMessage = document.getElementById('errorMessage');
        const lookupResult = document.getElementById('lookupResult');

        let bookData = null;

        // Drop zone handlers
        dropZone.addEventListener('click', () => fileInput.click());
        
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file && file.name.endsWith('.epub')) {
                processEpub(file);
            } else {
                showError('Please drop a valid EPUB file.');
            }
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                processEpub(file);
            }
        });

        // Reset button
        document.getElementById('resetBtn').addEventListener('click', () => {
            results.classList.remove('visible');
            errorMessage.classList.remove('visible');
            lookupResult.classList.remove('visible');
            fileInput.value = '';
            bookData = null;
        });

        // Lookup button
        document.getElementById('lookupBtn').addEventListener('click', performLookup);
        document.getElementById('locInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') performLookup();
        });

        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.classList.add('visible');
            results.classList.remove('visible');
        }

        async function processEpub(file) {
            errorMessage.classList.remove('visible');
            
            try {
                const zip = await JSZip.loadAsync(file);
                
                // Find container.xml to locate content.opf
                const containerXml = await zip.file('META-INF/container.xml')?.async('string');
                if (!containerXml) {
                    throw new Error('Invalid EPUB: Missing container.xml');
                }

                const parser = new DOMParser();
                const containerDoc = parser.parseFromString(containerXml, 'application/xml');
                const rootfilePath = containerDoc.querySelector('rootfile')?.getAttribute('full-path');
                
                if (!rootfilePath) {
                    throw new Error('Invalid EPUB: Cannot find content.opf path');
                }

                // Parse content.opf
                const opfContent = await zip.file(rootfilePath)?.async('string');
                if (!opfContent) {
                    throw new Error('Invalid EPUB: Cannot read content.opf');
                }

                const opfDoc = parser.parseFromString(opfContent, 'application/xml');
                const opfDir = rootfilePath.substring(0, rootfilePath.lastIndexOf('/') + 1);

                // Get book title
                const titleEl = opfDoc.querySelector('metadata title, dc\\:title');
                const bookTitle = titleEl?.textContent || file.name.replace('.epub', '');

                // Get spine items (reading order)
                const spineItems = opfDoc.querySelectorAll('spine itemref');
                const manifest = opfDoc.querySelectorAll('manifest item');
                
                // Build manifest map
                const manifestMap = {};
                manifest.forEach(item => {
                    manifestMap[item.getAttribute('id')] = item.getAttribute('href');
                });

                // Extract text from each spine item
                const chapters = [];
                let totalChars = 0;
                let totalWords = 0;

                for (const itemref of spineItems) {
                    const idref = itemref.getAttribute('idref');
                    const href = manifestMap[idref];
                    
                    if (!href) continue;

                    const filePath = opfDir + href;
                    const content = await zip.file(filePath)?.async('string');
                    
                    if (!content) continue;

                    const contentDoc = parser.parseFromString(content, 'application/xhtml+xml');
                    const textContent = extractText(contentDoc.body || contentDoc.documentElement);
                    
                    if (textContent.trim().length < 100) continue; // Skip very short files (likely nav, etc.)

                    const charCount = textContent.length;
                    const wordCount = textContent.split(/\s+/).filter(w => w.length > 0).length;

                    // Try to extract chapter title
                    const headings = contentDoc.querySelectorAll('h1, h2, h3, title');
                    let chapterTitle = '';
                    for (const h of headings) {
                        const text = h.textContent.trim();
                        if (text.length > 0 && text.length < 100) {
                            chapterTitle = text;
                            break;
                        }
                    }
                    if (!chapterTitle) {
                        chapterTitle = `Section ${chapters.length + 1}`;
                    }

                    chapters.push({
                        title: chapterTitle,
                        chars: charCount,
                        words: wordCount,
                        startChar: totalChars
                    });

                    totalChars += charCount;
                    totalWords += wordCount;
                }

                if (chapters.length === 0) {
                    throw new Error('Could not extract any content from the EPUB. It may be DRM-protected.');
                }

                // Calculate LOCs (128 bytes per LOC)
                const totalLocs = Math.ceil(totalChars / 128);
                
                // Calculate LOC ranges for each chapter
                let runningLoc = 1;
                chapters.forEach(ch => {
                    ch.locStart = runningLoc;
                    ch.locEnd = runningLoc + Math.ceil(ch.chars / 128) - 1;
                    ch.percentage = ((ch.chars / totalChars) * 100).toFixed(1);
                    runningLoc = ch.locEnd + 1;
                });

                // Store for lookup
                bookData = {
                    title: bookTitle,
                    totalLocs,
                    totalChars,
                    totalWords,
                    chapters
                };

                // Display results
                displayResults(bookData);

            } catch (error) {
                console.error(error);
                showError(error.message || 'Failed to process EPUB file.');
            }
        }

        function extractText(element) {
            if (!element) return '';
            
            let text = '';
            const walker = document.createTreeWalker(
                element,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );

            let node;
            while (node = walker.nextNode()) {
                text += node.textContent + ' ';
            }

            return text.replace(/\s+/g, ' ').trim();
        }

        function displayResults(data) {
            document.getElementById('bookTitle').textContent = data.title;
            document.getElementById('totalLocs').textContent = data.totalLocs.toLocaleString();
            document.getElementById('totalChars').textContent = data.totalChars.toLocaleString();
            document.getElementById('chapterCount').textContent = data.chapters.length;
            document.getElementById('wordCount').textContent = data.totalWords.toLocaleString();

            // Build chapter table
            const tbody = document.getElementById('chapterTable');
            tbody.innerHTML = '';

            data.chapters.forEach(ch => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${escapeHtml(ch.title)}</td>
                    <td>${ch.locStart.toLocaleString()}</td>
                    <td>${ch.locEnd.toLocaleString()}</td>
                    <td>${ch.percentage}%</td>
                `;
                tbody.appendChild(row);
            });

            results.classList.add('visible');
        }

        function performLookup() {
            if (!bookData) return;

            const locInput = document.getElementById('locInput');
            const loc = parseInt(locInput.value, 10);

            if (isNaN(loc) || loc < 1) {
                return;
            }

            const percentage = Math.min(100, (loc / bookData.totalLocs) * 100);
            document.getElementById('progressBar').style.width = percentage + '%';

            let chapterInfo = 'Beyond the end of the book';
            if (loc <= bookData.totalLocs) {
                for (const ch of bookData.chapters) {
                    if (loc >= ch.locStart && loc <= ch.locEnd) {
                        const chapterProgress = ((loc - ch.locStart) / (ch.locEnd - ch.locStart + 1) * 100).toFixed(0);
                        chapterInfo = `In "${ch.title}" (${chapterProgress}% through this chapter)`;
                        break;
                    }
                }
            }

            document.getElementById('lookupText').textContent = 
                `LOC ${loc.toLocaleString()} is ${percentage.toFixed(1)}% through the book. ${chapterInfo}`;
            
            lookupResult.classList.add('visible');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
    </script>

    <footer>
        <a href="https://tools.ben.report">Home</a>
        <a href="https://github.com/penborter/tools/blob/main/epub-locs.html">View Source</a>
    </footer>
</body>
</html>
